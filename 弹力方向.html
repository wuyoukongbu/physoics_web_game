<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ»‘ç¨½æ—‹è½¬ç«æŸ´äººå¤§ç‚®</title>
  <style>
    /* åŸºç¡€æ ·å¼é‡ç½® */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* é¡µé¢æ•´ä½“æ ·å¼ */
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
      user-select: none;
    }

    /* ç”»å¸ƒæ ·å¼ */
    canvas {
      background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
      display: block;
      cursor: crosshair;
      border: 3px solid #fff;
      box-shadow: 0 0 30px rgba(0,0,0,0.3);
    }

    /* UIå®¹å™¨ */
    .ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* å…è®¸é¼ æ ‡äº‹ä»¶ç©¿é€åˆ°canvas */
    }

    /* æ§åˆ¶é¢æ¿ */
    .control-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      pointer-events: auto; /* å…è®¸äº¤äº’ */
    }

    /* æŒ‰é’®é€šç”¨æ ·å¼ */
    .btn {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn-reset {
      background: linear-gradient(45deg, #ff6b6b, #ee5a52);
      color: white;
    }

    .btn-reset:hover {
      background: linear-gradient(45deg, #ee5a52, #ff6b6b);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,107,107,0.4);
    }

    .btn-clear {
      background: linear-gradient(45deg, #4ecdc4, #44a08d);
      color: white;
    }

    .btn-clear:hover {
      background: linear-gradient(45deg, #44a08d, #4ecdc4);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(78,205,196,0.4);
    }

    .btn-force {
      background: linear-gradient(45deg, #ffd700, #ffb300);
      color: #333;
    }

    .btn-force:hover {
      background: linear-gradient(45deg, #ffb300, #ffd700);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,215,0,0.4);
    }

    .btn-force.active {
      background: linear-gradient(45deg, #ff6b6b, #ee5a52);
      color: white;
    }

    .btn-draw {
      background: linear-gradient(45deg, #9b59b6, #8e44ad);
      color: white;
    }

    .btn-draw:hover {
      background: linear-gradient(45deg, #8e44ad, #9b59b6);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(155,89,182,0.4);
    }

    .btn-draw.active {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      color: white;
    }

    .btn-clear-terrain {
      background: linear-gradient(45deg, #f39c12, #e67e22);
      color: white;
    }

    .btn-clear-terrain:hover {
      background: linear-gradient(45deg, #e67e22, #f39c12);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(243,156,18,0.4);
    }

    /* ä¿¡æ¯é¢æ¿ */
    .info-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      pointer-events: auto;
      min-width: 200px;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 14px;
      color: #333;
    }

    .info-label {
      font-weight: bold;
      color: #666;
    }

    .info-value {
      color: #2c3e50;
      font-weight: bold;
    }

    /* åŠ›åº¦æŒ‡ç¤ºå™¨ */
    .power-indicator {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
      border-radius: 25px;
      padding: 15px 30px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      pointer-events: auto;
    }

    .power-bar {
      width: 300px;
      height: 30px;
      background: #e0e0e0;
      border-radius: 15px;
      overflow: hidden;
      position: relative;
      margin-top: 8px;
      cursor: pointer;
      border: 2px solid #ddd;
    }

    .power-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A, #CDDC39, #FFC107, #FF9800, #FF5722);
      width: 50%;
      transition: width 0.1s ease;
      border-radius: 13px;
      position: relative;
    }

    .power-slider {
      position: absolute;
      right: -15px;
      top: 50%;
      transform: translateY(-50%);
      width: 30px;
      height: 30px;
      background: #fff;
      border-radius: 50%;
      cursor: grab;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      border: 3px solid #007bff;
      transition: all 0.2s ease;
    }

    .power-slider:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }

    .power-slider:active {
      cursor: grabbing;
      transform: translateY(-50%) scale(0.95);
    }

    .power-label {
      text-align: center;
      font-weight: bold;
      color: #333;
      font-size: 16px;
    }

<!--    /* æ“ä½œè¯´æ˜ */-->
<!--    .instructions {-->
<!--      position: absolute;-->
<!--      bottom: 20px;-->
<!--      right: 20px;-->
<!--      background: rgba(255,255,255,0.9);-->
<!--      backdrop-filter: blur(10px);-->
<!--      border-radius: 15px;-->
<!--      padding: 15px;-->
<!--      box-shadow: 0 8px 32px rgba(0,0,0,0.1);-->
<!--      max-width: 280px;-->
<!--      font-size: 14px;-->
<!--      color: #333;-->
<!--      line-height: 1.5;-->
<!--      pointer-events: auto;-->
<!--    }-->

    /* èƒŒæ™¯æ ‡é¢˜ */
    .title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: rgba(255,255,255,0.1);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
      pointer-events: none;
      z-index: -1;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="ui-container">
    <div class="title">ç«æŸ´äººå¤§ç‚®</div>

    <div class="control-panel">
      <button id="resetBtn" class="btn btn-reset">ğŸ”„ é‡ç½®</button>
      <button id="clearBtn" class="btn btn-clear">ğŸ§¹ æ¸…ç©ºè½¨è¿¹</button>
      <button id="showForceBtn" class="btn btn-force">âš¡ æ˜¾ç¤ºå¼¹åŠ›</button>
      <button id="drawBtn" class="btn btn-draw">ğŸ–Œï¸ ç”»ç¬”</button>
      <button id="clearTerrainBtn" class="btn btn-clear-terrain">ğŸ—‘ï¸ æ¸…ç©ºåœ°å½¢</button>
    </div>

    <div class="info-panel">
      <div class="info-item">
        <span class="info-label">ç«æŸ´äººæ•°é‡:</span>
        <span class="info-value" id="humanCount">0</span>
      </div>
      <div class="info-item">
        <span class="info-label">å‘å°„è§’åº¦:</span>
        <span class="info-value" id="angleDisplay">0Â°</span>
      </div>
      <div class="info-item">
        <span class="info-label">å¼¹è·³æ¬¡æ•°:</span>
        <span class="info-value" id="bounceCount">0</span>
      </div>
    </div>

    <div class="power-indicator">
      <div class="power-label">å‘å°„åŠ›åº¦ (<span id="powerValue">10</span>)</div>
      <div class="power-bar" id="powerBar">
        <div class="power-fill" id="powerFill">
          <div class="power-slider" id="powerSlider"></div>
        </div>
      </div>
    </div>

<!--    <div class="instructions">-->
<!--      <strong>ğŸ® æ“ä½œè¯´æ˜:</strong><br>-->
<!--      â€¢ ç§»åŠ¨é¼ æ ‡ç„å‡†<br>-->
<!--      â€¢ æ»šè½®æˆ–æ‹–åŠ¨ä¸‹æ–¹æ»‘å—è°ƒèŠ‚åŠ›åº¦<br>-->
<!--      â€¢ ç‚¹å‡»å‘å°„ç«æŸ´äºº<br>-->
<!--      â€¢ ç«æŸ´äººä¼šå¼¹è·³5æ¬¡ååœæ­¢<br>-->
<!--      â€¢ ä½¿ç”¨ç”»ç¬”ç»˜åˆ¶åœ°å½¢-->
<!--    </div>-->
  </div>

<script>
// --- å…¨å±€å˜é‡å’Œåˆå§‹åŒ– ---
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// æ¸¸æˆçŠ¶æ€å˜é‡
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;
let power = 10;
let totalBounces = 0;
let isDraggingPower = false;
let showForce = false;
let drawingMode = false;
let isDrawing = false;
let lastDrawX = 0;
let lastDrawY = 0;

// æ¸¸æˆå¯¹è±¡æ•°ç»„
const humans = [];
const bounceArrows = [];
const particles = [];
const terrainPaths = [];
let currentPath = [];

// ç‰©ç†å¸¸é‡
const gravity = 0.05;

// --- æ¸¸æˆå¯¹è±¡ç±»å®šä¹‰ ---

// ç²’å­æ•ˆæœç±»
class Particle {
  constructor(x, y, vx, vy, color, life) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    this.size = Math.random() * 3 + 1;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.1;
    this.life--;
    this.vx *= 0.99;
    this.vy *= 0.99;
  }

  draw() {
    const alpha = this.life / this.maxLife;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.restore();
  }
}

// å¤§ç‚®ç±»
class Cannon {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.angle = 0;
  }

  updateAngle(mx, my) {
    this.angle = Math.atan2(my - this.y, mx - this.x);
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
    ctx.fillStyle = "#2c3e50";
    ctx.fill();
    ctx.strokeStyle = "#34495e";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = "#34495e";
    ctx.fillRect(0, -12, 70, 24);
    ctx.fillStyle = "#2c3e50";
    ctx.fillRect(0, -8, 70, 16);
    ctx.fillStyle = "#1a252f";
    ctx.fillRect(65, -10, 8, 20);
    ctx.restore();

    ctx.save();
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = "rgba(255,255,255,0.6)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + Math.cos(this.angle) * 200, this.y + Math.sin(this.angle) * 200);
    ctx.stroke();
    ctx.restore();
  }
}

// ç«æŸ´äººç±»
class Human {
  constructor(x, y, vx, vy) {
    this.radius = 15;
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.bounceCount = 0;
    this.maxBounces = 5;
    this.stopped = false;
    this.rotation = Math.atan2(vy, vx);
    this.trail = [];
  }

  update() {
    if (this.stopped) return;

    this.trail.push({x: this.x, y: this.y});

    this.vy += gravity;
    this.x += this.vx;
    this.y += this.vy;

    // **ä¿®æ”¹ç‚¹**: å°äººæœå‘è¿åŠ¨è½¨è¿¹çš„åˆ‡çº¿æ–¹å‘
    if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
      this.rotation = Math.atan2(this.vy, this.vx) + Math.PI;
    }

    const bounceForce = 30;
    let bounced = false;
    let fx = 0, fy = 0;

    // è¾¹ç•Œç¢°æ’æ£€æµ‹
    if (this.x - this.radius < 0) {
      this.x = this.radius; this.vx *= -0.8; fx = bounceForce; bounced = true;
    } else if (this.x + this.radius > canvas.width) {
      this.x = canvas.width - this.radius; this.vx *= -0.8; fx = -bounceForce; bounced = true;
    }
    if (this.y + this.radius > canvas.height) {
      this.y = canvas.height - this.radius; this.vy *= -0.8; fy = -bounceForce; bounced = true;
    }
    if (this.y - this.radius < 0) {
      this.y = this.radius; this.vy *= -0.8; fy = bounceForce; bounced = true;
    }

    // åœ°å½¢ç¢°æ’æ£€æµ‹ (åœ†ä¸çº¿æ®µç¢°æ’)
    const terrainLineWidth = 20;
    const terrainRadius = terrainLineWidth / 2;
    let collisionOccurred = false;

    for (const path of terrainPaths) {
        if (collisionOccurred) break;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i+1];

            const l2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2;
            if (l2 === 0) continue;

            let t = ((this.x - p1.x) * (p2.x - p1.x) + (this.y - p1.y) * (p2.y - p1.y)) / l2;
            t = Math.max(0, Math.min(1, t));

            const closestX = p1.x + t * (p2.x - p1.x);
            const closestY = p1.y + t * (p2.y - p1.y);

            const dx = this.x - closestX;
            const dy = this.y - closestY;
            const distSq = dx*dx + dy*dy;

            if (distSq < (this.radius + terrainRadius)**2) {
                const dist = Math.sqrt(distSq);
                const normalX = dx / dist;
                const normalY = dy / dist;

                const overlap = this.radius + terrainRadius - dist;
                this.x += normalX * overlap;
                this.y += normalY * overlap;

                const dotProduct = this.vx * normalX + this.vy * normalY;
                this.vx = (this.vx - 2 * dotProduct * normalX) * 0.8;
                this.vy = (this.vy - 2 * dotProduct * normalY) * 0.8;

                fx = normalX * bounceForce;
                fy = normalY * bounceForce;
                bounced = true;
                collisionOccurred = true;
                break;
            }
        }
    }


    if (bounced) {
      bounceArrows.push(new Arrow(this.x, this.y, fx, fy));
      this.bounceCount++;
      totalBounces++;

      for (let i = 0; i < 10; i++) {
        particles.push(new Particle(
          this.x, this.y,
          (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5,
          `hsl(${Math.random() * 60 + 20}, 100%, 70%)`, 30
        ));
      }

      if (this.bounceCount >= this.maxBounces) {
        this.stopped = true;
        this.vx = 0;
        this.vy = 0;
      }
    }
  }

  draw() {
    if (this.trail.length > 1) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(this.trail[0].x, this.trail[0].y);
      for (let i = 1; i < this.trail.length; i++) {
        ctx.lineTo(this.trail[i].x, this.trail[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);

    // **ä¿®æ”¹ç‚¹**: ç»˜åˆ¶å®Œæ•´çš„ç«æŸ´äººèº«ä½“
    // èº«ä½“å’Œå››è‚¢
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.lineCap = "round";

    // èº«ä½“ (ä»å¤´éƒ¨ä¸­å¿ƒå‘è¿åŠ¨æ–¹å‘å»¶ä¼¸)
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(25, 0);
    ctx.stroke();

    // æ‰‹è‡‚
    ctx.beginPath();
    ctx.moveTo(12, 0);
    ctx.lineTo(18, -10);
    ctx.moveTo(12, 0);
    ctx.lineTo(18, 10);
    ctx.stroke();

    // è…¿
    ctx.beginPath();
    ctx.moveTo(25, 0);
    ctx.lineTo(35, -8);
    ctx.moveTo(25, 0);
    ctx.lineTo(35, 8);
    ctx.stroke();

    // å¤´éƒ¨ (æœ€åç»˜åˆ¶ä»¥è¦†ç›–èº«ä½“è¿æ¥å¤„)
    ctx.beginPath();
    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#ffd700";
    ctx.fill();
    ctx.strokeStyle = "#ffb300";
    ctx.lineWidth = 2;
    ctx.stroke();

    // è¡¨æƒ… (é¢å‘å‰è¿›æ–¹å‘)
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(this.radius * 0.4, -this.radius * 0.3, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(this.radius * 0.4, this.radius * 0.3, 1.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(this.radius * 0.6, 0, 4, Math.PI * 1.5, Math.PI * 0.5, false);
    ctx.stroke();

    ctx.restore();
  }
}

// å¼¹åŠ›ç®­å¤´ç±»
class Arrow {
  constructor(x, y, fx, fy) {
    this.x = x;
    this.y = y;
    this.fx = fx;
    this.fy = fy;
  }

  draw() {
    if (!showForce) return;

    const dx = this.fx * 3;
    const dy = this.fy * 3;
    const endX = this.x + dx;
    const endY = this.y + dy;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = "#ff4757";
    ctx.lineWidth = 8;
    ctx.lineCap = "round";
    ctx.stroke();

    const angle = Math.atan2(dy, dx);
    const headSize = 20;
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6), endY - headSize * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6), endY - headSize * Math.sin(angle + Math.PI / 6));
    ctx.stroke();

    ctx.restore();
  }
}

// --- å®ä¾‹åˆ›å»ºå’ŒUIæ›´æ–° ---
const cannon = new Cannon(100, canvas.height - 100);

function updatePowerDisplay() {
  const powerPercent = ((power - 5) / 20) * 100;
  document.getElementById("powerFill").style.width = powerPercent + "%";
  document.getElementById("powerValue").textContent = Math.round(power);
}

function updatePowerFromMouse(e) {
  const rect = powerBar.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const percent = Math.max(0, Math.min(1, x / rect.width));
  power = 5 + percent * 20;
  updatePowerDisplay();
}

// --- äº‹ä»¶ç›‘å¬å™¨ ---

// åŠ›åº¦æ¡æ‹–æ‹½
const powerBar = document.getElementById("powerBar");
powerBar.addEventListener("mousedown", (e) => {
  isDraggingPower = true;
  updatePowerFromMouse(e);
});
document.addEventListener("mousemove", (e) => {
  if (isDraggingPower) {
    updatePowerFromMouse(e);
  }
});
document.addEventListener("mouseup", () => {
  isDraggingPower = false;
});

// é¼ æ ‡åœ¨ç”»å¸ƒä¸Šç§»åŠ¨
canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const currentX = e.clientX - rect.left;
  const currentY = e.clientY - rect.top;

  if (drawingMode) {
    if (isDrawing) {
      const dx = currentX - lastDrawX;
      const dy = currentY - lastDrawY;
      if (dx * dx + dy * dy > 25) { // Add point if moved enough
        currentPath.push({ x: currentX, y: currentY });
        lastDrawX = currentX;
        lastDrawY = currentY;
      }
    }
  } else {
    mouseX = e.clientX;
    mouseY = e.clientY;
    cannon.updateAngle(mouseX, mouseY);
    const angleDeg = cannon.angle * 180 / Math.PI;
    document.getElementById("angleDisplay").textContent = Math.round(angleDeg) + "Â°";
  }
});

// é¼ æ ‡æ»šè½®è°ƒèŠ‚åŠ›åº¦
canvas.addEventListener("wheel", (e) => {
  if (!drawingMode) {
    e.preventDefault();
    power += e.deltaY > 0 ? -1 : 1;
    power = Math.max(5, Math.min(25, power));
    updatePowerDisplay();
  }
});

// é¼ æ ‡åœ¨ç”»å¸ƒä¸ŠæŒ‰ä¸‹
canvas.addEventListener("mousedown", (e) => {
  if (drawingMode) {
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    lastDrawX = e.clientX - rect.left;
    lastDrawY = e.clientY - rect.top;
    currentPath = [{ x: lastDrawX, y: lastDrawY }];
    terrainPaths.push(currentPath);
  }
});

// é¼ æ ‡åœ¨ç”»å¸ƒä¸ŠæŠ¬èµ·
canvas.addEventListener("mouseup", () => {
  if (drawingMode) {
    isDrawing = false;
    currentPath = [];
  }
});

// ç‚¹å‡»ç”»å¸ƒå‘å°„
canvas.addEventListener("click", (e) => {
  if (!drawingMode && !isDraggingPower) {
    const angle = cannon.angle;
    const vx = Math.cos(angle) * power;
    const vy = Math.sin(angle) * power;

    humans.push(new Human(
      cannon.x + Math.cos(angle) * 70,
      cannon.y + Math.sin(angle) * 70,
      vx, vy
    ));

    for (let i = 0; i < 15; i++) {
      particles.push(new Particle(
        cannon.x + Math.cos(angle) * 70,
        cannon.y + Math.sin(angle) * 70,
        vx * 0.3 + (Math.random() - 0.5) * 3,
        vy * 0.3 + (Math.random() - 0.5) * 3,
        `hsl(${Math.random() * 60 + 300}, 70%, 60%)`, 40
      ));
    }
    document.getElementById("humanCount").textContent = humans.length;
  }
});

// æŒ‰é’®äº‹ä»¶
document.getElementById("resetBtn").addEventListener("click", () => {
  humans.length = 0;
  bounceArrows.length = 0;
  particles.length = 0;
  terrainPaths.length = 0;
  totalBounces = 0;
  document.getElementById("humanCount").textContent = "0";
  document.getElementById("bounceCount").textContent = "0";
});

document.getElementById("clearBtn").addEventListener("click", () => {
  bounceArrows.length = 0;
  particles.length = 0;
  humans.forEach(human => human.trail = []);
});

document.getElementById("showForceBtn").addEventListener("click", (e) => {
  showForce = !showForce;
  const btn = e.currentTarget;
  if (showForce) {
    btn.textContent = "âŒ éšè—å¼¹åŠ›";
    btn.classList.add("active");
  } else {
    btn.textContent = "âš¡ æ˜¾ç¤ºå¼¹åŠ›";
    btn.classList.remove("active");
  }
});

document.getElementById("drawBtn").addEventListener("click", (e) => {
  drawingMode = !drawingMode;
  const btn = e.currentTarget;
  if (drawingMode) {
    btn.textContent = "ğŸ¯ å‘å°„æ¨¡å¼";
    btn.classList.add("active");
    canvas.style.cursor = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" style=\"font-size:24px\"><text y=\"24\">ğŸ–Œï¸</text></svg>') 16 16, crosshair";
  } else {
    btn.textContent = "ğŸ–Œï¸ ç”»ç¬”";
    btn.classList.remove("active");
    canvas.style.cursor = "crosshair";
  }
});

document.getElementById("clearTerrainBtn").addEventListener("click", () => {
  terrainPaths.length = 0;
});

// çª—å£å¤§å°æ”¹å˜æ—¶é‡ç½®ç”»å¸ƒå°ºå¯¸
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    cannon.y = canvas.height - 100;
});

// --- æ¸¸æˆä¸»å¾ªç¯ ---
function animate() {
  requestAnimationFrame(animate);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ç»˜åˆ¶åœ°å½¢è·¯å¾„
  ctx.save();
  ctx.strokeStyle = "#8B4513";
  ctx.lineWidth = 20; // åœ°å½¢çº¿æ¡å®½åº¦
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  terrainPaths.forEach(path => {
    if (path.length < 2) {
        if (path.length === 1) {
            ctx.fillStyle = "#8B4513";
            ctx.beginPath();
            ctx.arc(path[0].x, path[0].y, ctx.lineWidth / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        return;
    };
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
  });
  ctx.restore();

  if (!drawingMode) {
    cannon.draw();
  }

  bounceArrows.forEach(arrow => arrow.draw());

  humans.forEach(h => {
    h.update();
    h.draw();
  });

  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].draw();
    if (particles[i].life <= 0) {
      particles.splice(i, 1);
    }
  }

  document.getElementById("bounceCount").textContent = totalBounces;
}

// --- æ¸¸æˆå¯åŠ¨ ---
updatePowerDisplay();
animate();

</script>
</body>
</html>
